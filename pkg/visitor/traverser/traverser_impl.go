// Code generated by "go generate go run traverser_gen.go"; DO NOT EDIT.

package traverser

import "github.com/laytan/php-parser/pkg/ast"

func (t *Traverser) Root(n *ast.Root) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) Nullable(n *ast.Nullable) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) Union(n *ast.Union) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Types {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) Intersection(n *ast.Intersection) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Types {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) Parameter(n *ast.Parameter) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.AttrGroups {
        nn.Accept(t)
    }

    t.Traverse(n.DefaultValue)

    for _, nn := range n.Modifiers {
        nn.Accept(t)
    }

    t.Traverse(n.Type)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) Identifier(n *ast.Identifier) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.leave(n)
}

func (t *Traverser) Argument(n *ast.Argument) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Name)

    t.leave(n)
}

func (t *Traverser) Attribute(n *ast.Attribute) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Args {
        nn.Accept(t)
    }

    t.Traverse(n.Name)

    t.leave(n)
}

func (t *Traverser) AttributeGroup(n *ast.AttributeGroup) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Attrs {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) ScalarDnumber(n *ast.ScalarDnumber) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.leave(n)
}

func (t *Traverser) ScalarEncapsed(n *ast.ScalarEncapsed) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Parts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) ScalarEncapsedStringPart(n *ast.ScalarEncapsedStringPart) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.leave(n)
}

func (t *Traverser) ScalarEncapsedStringVar(n *ast.ScalarEncapsedStringVar) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Dim)

    t.Traverse(n.Name)

    t.leave(n)
}

func (t *Traverser) ScalarEncapsedStringBrackets(n *ast.ScalarEncapsedStringBrackets) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ScalarHeredoc(n *ast.ScalarHeredoc) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Parts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) ScalarLnumber(n *ast.ScalarLnumber) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.leave(n)
}

func (t *Traverser) ScalarMagicConstant(n *ast.ScalarMagicConstant) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.leave(n)
}

func (t *Traverser) ScalarString(n *ast.ScalarString) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.leave(n)
}

func (t *Traverser) StmtBreak(n *ast.StmtBreak) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) StmtCase(n *ast.StmtCase) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Cond)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtCatch(n *ast.StmtCatch) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    for _, nn := range n.Types {
        nn.Accept(t)
    }

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) StmtEnum(n *ast.StmtEnum) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.AttrGroups {
        nn.Accept(t)
    }

    for _, nn := range n.Implements {
        nn.Accept(t)
    }

    t.Traverse(n.Name)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    t.Traverse(n.Type)

    t.leave(n)
}

func (t *Traverser) EnumCase(n *ast.EnumCase) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.AttrGroups {
        nn.Accept(t)
    }

    t.Traverse(n.Expr)

    t.Traverse(n.Name)

    t.leave(n)
}

func (t *Traverser) StmtClass(n *ast.StmtClass) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Args {
        nn.Accept(t)
    }

    for _, nn := range n.AttrGroups {
        nn.Accept(t)
    }

    t.Traverse(n.Extends)

    for _, nn := range n.Implements {
        nn.Accept(t)
    }

    for _, nn := range n.Modifiers {
        nn.Accept(t)
    }

    t.Traverse(n.Name)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtClassConstList(n *ast.StmtClassConstList) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.AttrGroups {
        nn.Accept(t)
    }

    for _, nn := range n.Consts {
        nn.Accept(t)
    }

    for _, nn := range n.Modifiers {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtClassMethod(n *ast.StmtClassMethod) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.AttrGroups {
        nn.Accept(t)
    }

    for _, nn := range n.Modifiers {
        nn.Accept(t)
    }

    t.Traverse(n.Name)

    for _, nn := range n.Params {
        nn.Accept(t)
    }

    t.Traverse(n.ReturnType)

    t.Traverse(n.Stmt)

    t.leave(n)
}

func (t *Traverser) StmtConstList(n *ast.StmtConstList) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Consts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtConstant(n *ast.StmtConstant) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Name)

    t.leave(n)
}

func (t *Traverser) StmtContinue(n *ast.StmtContinue) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) StmtDeclare(n *ast.StmtDeclare) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Consts {
        nn.Accept(t)
    }

    t.Traverse(n.Stmt)

    t.leave(n)
}

func (t *Traverser) StmtDefault(n *ast.StmtDefault) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtDo(n *ast.StmtDo) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Cond)

    t.Traverse(n.Stmt)

    t.leave(n)
}

func (t *Traverser) StmtEcho(n *ast.StmtEcho) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Exprs {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtElse(n *ast.StmtElse) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Stmt)

    t.leave(n)
}

func (t *Traverser) StmtElseIf(n *ast.StmtElseIf) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Cond)

    t.Traverse(n.Stmt)

    t.leave(n)
}

func (t *Traverser) StmtExpression(n *ast.StmtExpression) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) StmtFinally(n *ast.StmtFinally) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtFor(n *ast.StmtFor) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Cond {
        nn.Accept(t)
    }

    for _, nn := range n.Init {
        nn.Accept(t)
    }

    for _, nn := range n.Loop {
        nn.Accept(t)
    }

    t.Traverse(n.Stmt)

    t.leave(n)
}

func (t *Traverser) StmtForeach(n *ast.StmtForeach) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Key)

    t.Traverse(n.Stmt)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) StmtFunction(n *ast.StmtFunction) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.AttrGroups {
        nn.Accept(t)
    }

    t.Traverse(n.Name)

    for _, nn := range n.Params {
        nn.Accept(t)
    }

    t.Traverse(n.ReturnType)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtGlobal(n *ast.StmtGlobal) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Vars {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtGoto(n *ast.StmtGoto) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Label)

    t.leave(n)
}

func (t *Traverser) StmtHaltCompiler(n *ast.StmtHaltCompiler) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.leave(n)
}

func (t *Traverser) StmtIf(n *ast.StmtIf) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Cond)

    t.Traverse(n.Else)

    for _, nn := range n.ElseIf {
        nn.Accept(t)
    }

    t.Traverse(n.Stmt)

    t.leave(n)
}

func (t *Traverser) StmtInlineHtml(n *ast.StmtInlineHtml) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.leave(n)
}

func (t *Traverser) StmtInterface(n *ast.StmtInterface) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.AttrGroups {
        nn.Accept(t)
    }

    for _, nn := range n.Extends {
        nn.Accept(t)
    }

    t.Traverse(n.Name)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtLabel(n *ast.StmtLabel) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Name)

    t.leave(n)
}

func (t *Traverser) StmtNamespace(n *ast.StmtNamespace) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Name)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtNop(n *ast.StmtNop) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.leave(n)
}

func (t *Traverser) StmtProperty(n *ast.StmtProperty) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) StmtPropertyList(n *ast.StmtPropertyList) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.AttrGroups {
        nn.Accept(t)
    }

    for _, nn := range n.Modifiers {
        nn.Accept(t)
    }

    for _, nn := range n.Props {
        nn.Accept(t)
    }

    t.Traverse(n.Type)

    t.leave(n)
}

func (t *Traverser) StmtReturn(n *ast.StmtReturn) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) StmtStatic(n *ast.StmtStatic) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Vars {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtStaticVar(n *ast.StmtStaticVar) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) StmtStmtList(n *ast.StmtStmtList) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtSwitch(n *ast.StmtSwitch) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Cases {
        nn.Accept(t)
    }

    t.Traverse(n.Cond)

    t.leave(n)
}

func (t *Traverser) StmtThrow(n *ast.StmtThrow) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) StmtTrait(n *ast.StmtTrait) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.AttrGroups {
        nn.Accept(t)
    }

    t.Traverse(n.Name)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtTraitUse(n *ast.StmtTraitUse) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Adaptations {
        nn.Accept(t)
    }

    for _, nn := range n.Traits {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtTraitUseAlias(n *ast.StmtTraitUseAlias) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Alias)

    t.Traverse(n.Method)

    t.Traverse(n.Modifier)

    t.Traverse(n.Trait)

    t.leave(n)
}

func (t *Traverser) StmtTraitUsePrecedence(n *ast.StmtTraitUsePrecedence) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Insteadof {
        nn.Accept(t)
    }

    t.Traverse(n.Method)

    t.Traverse(n.Trait)

    t.leave(n)
}

func (t *Traverser) StmtTry(n *ast.StmtTry) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Catches {
        nn.Accept(t)
    }

    t.Traverse(n.Finally)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtUnset(n *ast.StmtUnset) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Vars {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtUse(n *ast.StmtUseList) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Type)

    for _, nn := range n.Uses {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtGroupUse(n *ast.StmtGroupUseList) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Prefix)

    t.Traverse(n.Type)

    for _, nn := range n.Uses {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) StmtUseDeclaration(n *ast.StmtUse) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Alias)

    t.Traverse(n.Type)

    t.Traverse(n.Use)

    t.leave(n)
}

func (t *Traverser) StmtWhile(n *ast.StmtWhile) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Cond)

    t.Traverse(n.Stmt)

    t.leave(n)
}

func (t *Traverser) ExprArray(n *ast.ExprArray) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Items {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) ExprArrayDimFetch(n *ast.ExprArrayDimFetch) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Dim)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprArrayItem(n *ast.ExprArrayItem) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Key)

    t.Traverse(n.Val)

    t.leave(n)
}

func (t *Traverser) ExprArrowFunction(n *ast.ExprArrowFunction) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.AttrGroups {
        nn.Accept(t)
    }

    t.Traverse(n.Expr)

    for _, nn := range n.Params {
        nn.Accept(t)
    }

    t.Traverse(n.ReturnType)

    t.leave(n)
}

func (t *Traverser) ExprBitwiseNot(n *ast.ExprBitwiseNot) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprBooleanNot(n *ast.ExprBooleanNot) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprBrackets(n *ast.ExprBrackets) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprClassConstFetch(n *ast.ExprClassConstFetch) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Class)

    t.Traverse(n.Const)

    t.leave(n)
}

func (t *Traverser) ExprClone(n *ast.ExprClone) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprClosure(n *ast.ExprClosure) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.AttrGroups {
        nn.Accept(t)
    }

    for _, nn := range n.Params {
        nn.Accept(t)
    }

    t.Traverse(n.ReturnType)

    for _, nn := range n.Stmts {
        nn.Accept(t)
    }

    for _, nn := range n.Uses {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) ExprClosureUse(n *ast.ExprClosureUse) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprConstFetch(n *ast.ExprConstFetch) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Const)

    t.leave(n)
}

func (t *Traverser) ExprEmpty(n *ast.ExprEmpty) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprErrorSuppress(n *ast.ExprErrorSuppress) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprEval(n *ast.ExprEval) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprExit(n *ast.ExprExit) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprFunctionCall(n *ast.ExprFunctionCall) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Args {
        nn.Accept(t)
    }

    t.Traverse(n.Function)

    t.leave(n)
}

func (t *Traverser) ExprInclude(n *ast.ExprInclude) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprIncludeOnce(n *ast.ExprIncludeOnce) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprInstanceOf(n *ast.ExprInstanceOf) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Class)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprIsset(n *ast.ExprIsset) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Vars {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) ExprList(n *ast.ExprList) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Items {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) ExprMethodCall(n *ast.ExprMethodCall) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Args {
        nn.Accept(t)
    }

    t.Traverse(n.Method)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprNullsafeMethodCall(n *ast.ExprNullsafeMethodCall) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Args {
        nn.Accept(t)
    }

    t.Traverse(n.Method)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprNew(n *ast.ExprNew) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Args {
        nn.Accept(t)
    }

    t.Traverse(n.Class)

    t.leave(n)
}

func (t *Traverser) ExprPostDec(n *ast.ExprPostDec) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprPostInc(n *ast.ExprPostInc) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprPreDec(n *ast.ExprPreDec) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprPreInc(n *ast.ExprPreInc) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprPrint(n *ast.ExprPrint) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprPropertyFetch(n *ast.ExprPropertyFetch) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Prop)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprNullsafePropertyFetch(n *ast.ExprNullsafePropertyFetch) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Prop)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprRequire(n *ast.ExprRequire) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprRequireOnce(n *ast.ExprRequireOnce) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprShellExec(n *ast.ExprShellExec) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Parts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) ExprStaticCall(n *ast.ExprStaticCall) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Args {
        nn.Accept(t)
    }

    t.Traverse(n.Call)

    t.Traverse(n.Class)

    t.leave(n)
}

func (t *Traverser) ExprStaticPropertyFetch(n *ast.ExprStaticPropertyFetch) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Class)

    t.Traverse(n.Prop)

    t.leave(n)
}

func (t *Traverser) ExprTernary(n *ast.ExprTernary) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Cond)

    t.Traverse(n.IfFalse)

    t.Traverse(n.IfTrue)

    t.leave(n)
}

func (t *Traverser) ExprUnaryMinus(n *ast.ExprUnaryMinus) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprUnaryPlus(n *ast.ExprUnaryPlus) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprVariable(n *ast.ExprVariable) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Name)

    t.leave(n)
}

func (t *Traverser) ExprYield(n *ast.ExprYield) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Key)

    t.Traverse(n.Val)

    t.leave(n)
}

func (t *Traverser) ExprYieldFrom(n *ast.ExprYieldFrom) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprCastArray(n *ast.ExprCastArray) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprCastBool(n *ast.ExprCastBool) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprCastDouble(n *ast.ExprCastDouble) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprCastInt(n *ast.ExprCastInt) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprCastObject(n *ast.ExprCastObject) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprCastString(n *ast.ExprCastString) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprCastUnset(n *ast.ExprCastUnset) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprAssign(n *ast.ExprAssign) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignReference(n *ast.ExprAssignReference) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignBitwiseAnd(n *ast.ExprAssignBitwiseAnd) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignBitwiseOr(n *ast.ExprAssignBitwiseOr) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignBitwiseXor(n *ast.ExprAssignBitwiseXor) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignCoalesce(n *ast.ExprAssignCoalesce) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignConcat(n *ast.ExprAssignConcat) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignDiv(n *ast.ExprAssignDiv) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignMinus(n *ast.ExprAssignMinus) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignMod(n *ast.ExprAssignMod) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignMul(n *ast.ExprAssignMul) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignPlus(n *ast.ExprAssignPlus) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignPow(n *ast.ExprAssignPow) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignShiftLeft(n *ast.ExprAssignShiftLeft) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprAssignShiftRight(n *ast.ExprAssignShiftRight) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.Traverse(n.Var)

    t.leave(n)
}

func (t *Traverser) ExprBinaryBitwiseAnd(n *ast.ExprBinaryBitwiseAnd) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryBitwiseOr(n *ast.ExprBinaryBitwiseOr) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryBitwiseXor(n *ast.ExprBinaryBitwiseXor) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryBooleanAnd(n *ast.ExprBinaryBooleanAnd) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryBooleanOr(n *ast.ExprBinaryBooleanOr) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryCoalesce(n *ast.ExprBinaryCoalesce) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryConcat(n *ast.ExprBinaryConcat) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryDiv(n *ast.ExprBinaryDiv) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryEqual(n *ast.ExprBinaryEqual) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryGreater(n *ast.ExprBinaryGreater) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryGreaterOrEqual(n *ast.ExprBinaryGreaterOrEqual) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryIdentical(n *ast.ExprBinaryIdentical) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryLogicalAnd(n *ast.ExprBinaryLogicalAnd) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryLogicalOr(n *ast.ExprBinaryLogicalOr) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryLogicalXor(n *ast.ExprBinaryLogicalXor) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryMinus(n *ast.ExprBinaryMinus) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryMod(n *ast.ExprBinaryMod) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryMul(n *ast.ExprBinaryMul) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryNotEqual(n *ast.ExprBinaryNotEqual) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryNotIdentical(n *ast.ExprBinaryNotIdentical) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryPlus(n *ast.ExprBinaryPlus) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryPow(n *ast.ExprBinaryPow) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryShiftLeft(n *ast.ExprBinaryShiftLeft) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinaryShiftRight(n *ast.ExprBinaryShiftRight) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinarySmaller(n *ast.ExprBinarySmaller) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinarySmallerOrEqual(n *ast.ExprBinarySmallerOrEqual) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprBinarySpaceship(n *ast.ExprBinarySpaceship) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Left)

    t.Traverse(n.Right)

    t.leave(n)
}

func (t *Traverser) ExprMatch(n *ast.ExprMatch) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Arms {
        nn.Accept(t)
    }

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) ExprThrow(n *ast.ExprThrow) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.Traverse(n.Expr)

    t.leave(n)
}

func (t *Traverser) MatchArm(n *ast.MatchArm) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Exprs {
        nn.Accept(t)
    }

    t.Traverse(n.ReturnExpr)

    t.leave(n)
}

func (t *Traverser) NameName(n *ast.Name) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Parts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) NameFullyQualified(n *ast.NameFullyQualified) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Parts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) NameRelative(n *ast.NameRelative) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    for _, nn := range n.Parts {
        nn.Accept(t)
    }

    t.leave(n)
}

func (t *Traverser) NameNamePart(n *ast.NamePart) {
    if !t.checkEntrance(n) {
        return
    }

    n.Accept(t.v)

    t.leave(n)
}
